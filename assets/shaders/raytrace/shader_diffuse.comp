#version 460 core
layout(local_size_x =    , local_size_y =    , local_size_z =    ) in;
layout(rgba32f, binding = 0) writeonly restrict uniform image2D imageOut;


layout(location = 2) uniform vec4 u_dt;
layout(location = 3) uniform int  u_samplesPpx;
layout(location = 4) uniform int  u_recurseDepth;


const float c_infinity = 1. / 0.;
const float c_pi = 3.14159265358979323846264338327950288;


float degrees_to_radians(float degrees) { return degrees * c_pi / 180.0f; }


/* Watered-down version of: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl */
uint hash( uint x ) { // A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
    x += ( x << 10u ); x ^= ( x >>  6u );
    x += ( x <<  3u ); x ^= ( x >> 11u );
    x += ( x << 15u ); return x;
}


uint pcg_hash(uint x)
{
    uint state = x * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

uint  hash(uvec3 v)          { return hash(v.x ^ hash(v.y) ^ hash(v.z));                        }
float floatConstruct(uint m) { return uintBitsToFloat((m & 0x007FFFFFu) | 0x3F800000u ) - 1.0f; }
float random(float v)        { return floatConstruct(hash(floatBitsToUint(v)));                 }
float random3f(vec3 v)       { return floatConstruct(hash(floatBitsToUint(v)));                 }



vec3 randInUnitSphere(in vec2 texelCoord, in uint sampleNum)
{
    vec3 randPoint = vec3( float(1 << sampleNum) );
    randPoint += vec3(
        texelCoord.yx,
        random(texelCoord.x) * texelCoord.y
    );
    return normalize(vec3(
        random(randPoint.x), 
        random(randPoint.y), 
        random(randPoint.z)
    ));
}


struct Ray
{
    vec3 origin;
    vec3 dir;
};
vec3 rayAt(in Ray ray, in float t) { return ray.origin + ray.dir * t; }


struct Sphere 
{ 
    vec4 pos_radius; 
};




struct CameraTransform
{
    vec3  position;
    vec2  viewport;
    float focal_length; /* Distance from camera origin to camera Screen */
    int   reserved;
};
Ray cameraGetRay(CameraTransform cam, vec3 rayOrigin, vec2 uv) /* Camera pointing towards -Z axis */
{
    vec3 rayDir;
    rayDir = cam.position - vec3( (vec2(0.5f) - uv) * cam.viewport, cam.focal_length);
    return Ray(rayOrigin, rayDir);
}




layout(std430, binding=1) buffer SceneData
{
    CameraTransform transform;
    uint            max_objects;
    uint            curr_length;
    Sphere          objects[];
};




struct SphereRayIntersectionResult
{
    float t;
    vec3  normal;
};


void intersection(
    in  Ray    R, 
    in  Sphere S, 
    in  vec2   t_bounds, 
    out SphereRayIntersectionResult 
    result
) {
    float a, b, ac, discrim;
    vec3 tmp;
    vec2 coef;


    tmp = R.origin - S.pos_radius.xyz;
    b = -1.0f * dot(R.dir, tmp); /* calculate -b */
    a = dot(R.dir, R.dir);
    ac = dot(tmp, tmp) - S.pos_radius.w * S.pos_radius.w;

    b  *= (1.0f / a);
    ac *= (1.0f / a);
    discrim = b * b - ac;

    result.t = float(discrim < 0.0f) * c_infinity;
    if(isinf(result.t))
        return;


    coef = vec2(
        b + sqrt(discrim),
        b - sqrt(discrim)
    );
    coef = mix(vec2(c_infinity), coef, 
        bvec2(
            t_bounds.x < coef.x && coef.x < t_bounds.y,
            t_bounds.x < coef.y && coef.y < t_bounds.y
        )
    );
    result.t = min(coef.x, coef.y);
    if(isinf(result.t))
        return;


    result.normal  = rayAt(R, result.t) - S.pos_radius.xyz;
    result.normal *= (1.0f / S.pos_radius.w);
    result.normal *= mix(-1.0f, 1.0f, dot(R.dir, result.normal) < 0.0f); /* set proper direction if vector is outwards/inwards */
    // result.normal *= float(!isinf(result.t));
    return;
}


void worldRayIntersection(
    in  Sphere objects[2], 
    in  Ray ray, 
    out SphereRayIntersectionResult result
) {    
    SphereRayIntersectionResult curr_result, min_result;
    vec2 t_limits = vec2(0.001f, c_infinity);


    min_result.t      = c_infinity;
    min_result.normal = vec3(0.0f);
    for(int i = 0; i < 2; ++i)
    {
        intersection(ray, objects[i], t_limits, curr_result);
        // if(isinf(curr_result.t)) 
        //     continue; /* considering we don't have hundreds of objects, this should be fine without the conditional */

        
        if(curr_result.t < t_limits.y) {
            t_limits.y = curr_result.t;
            min_result = curr_result;
        }
    }
    result = min_result;
}


vec3 defaultRayColor(in Ray ray)
{
    vec3 unit = normalize(ray.dir);
    float t = 0.5f * (unit.y + 1.0f);
    
    return mix(
        vec3(1.0f, 1.0f, 1.0f),
        vec3(0.5f, 0.7f, 1.0f),
        t
    );
}



vec3 CalculatePixelColorDiffuse(in CameraTransform camera, in Sphere objects[2], in vec2 texelCoord)
{
    SphereRayIntersectionResult possibleHit;
    Ray cameraRayAtUV;
    vec3 returnedColor;
    uint mulHalf = 0;
    int  i       = 0;
    bool cont    = true;


    cameraRayAtUV = cameraGetRay(camera, camera.position, texelCoord);
    for(; i < u_recurseDepth && cont; ++i)
    {
        worldRayIntersection(objects, cameraRayAtUV, possibleHit);
        cont = !isinf(possibleHit.t);
        if(cont) {
            ++mulHalf;
            cameraRayAtUV.origin = rayAt(cameraRayAtUV, possibleHit.t);
            cameraRayAtUV.dir    = possibleHit.normal + randInUnitSphere(texelCoord, i);
        }
    }
    returnedColor = mix(
        defaultRayColor(cameraRayAtUV),
        vec3(0.0f),
        i == u_recurseDepth
    );
    return pow(0.5f, mulHalf) * returnedColor;
}





vec3 CalculatePixelColor(
    in CameraTransform camera, 
    in Sphere          objects[2], 
    in vec2            texelCoord
) {
    SphereRayIntersectionResult possibleHit;
    vec3 outColor = vec3(0.0f);
    Ray  cameraRayAtUV;
    vec2 currTexel;
    const float pixel_samples_inv = 1.0f / float(u_samplesPpx);


    /* for(uint sampleIdx = 0; sampleIdx < 1; ++sampleIdx) {} */
    for(uint sampleIdx = 0; sampleIdx < u_samplesPpx; ++sampleIdx) {

        // currTexel = texelCoord;
        // currTexel = texelCoord + vec2(clamp(
        //     random3f(  vec3(texelCoord, u_dt.x * sampleIdx)  ),
        //     0.000f,
        //     0.999f
        // ) * u_dt.x * pixel_samples_inv);
        currTexel = texelCoord + vec2(
            random(texelCoord.x * u_dt.y),
            random(texelCoord.y * u_dt.z)
        ) * pow(pixel_samples_inv, 3.14159f);

        outColor += CalculatePixelColorDiffuse(camera, objects, currTexel);
    }


    outColor *= pixel_samples_inv; /* Get Average over All Samples */
    return outColor;
}


void main()
{
    /* Image Output Coordinates (pixel uv coord) */
    ivec2 texelCoord  = ivec2(gl_GlobalInvocationID.xy);
    vec2  texelCoordf = vec2(texelCoord) / vec2(gl_NumWorkGroups.xy);
    vec2  currTexel;

    /* Output screen data */
    ivec2 windowSize  = imageSize(imageOut);
    float aspectRatio = float(windowSize.x) / float(windowSize.y);

    /* intermediates for calculations */
    vec3 finalColor = vec3(0.0f);


    // if(texelCoord.y + texelCoord.x * windowSize.x >= windowSize.x * windowSize.y) {
    //     return;
    // }

    CameraTransform camera = CameraTransform( /* in reality this would change its data on a resize of the window, which will be updated in the ssbo. */
        vec3(0.0f, 0.0f, 0.0f),         /* Position */
        vec2(aspectRatio * 2.0f, 2.0f), /* Viewport Width, height */
        1.0f,                           /* focal length */
        0                               /* reserved */
    );


    Sphere objects[2] = {
        Sphere(vec4(0.0f, 0.0f,    -1.0f, 0.5f  )),
        Sphere(vec4(0.0f, -100.5f, -1.0f, 100.0f))
    };


    texelCoord  = ivec2(gl_GlobalInvocationID.xy);
    texelCoordf = vec2(gl_GlobalInvocationID.xy) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);
    finalColor = CalculatePixelColor(camera, objects, texelCoordf);
    finalColor = pow(finalColor, vec3(1.0f/2.2f));
    imageStore(imageOut, texelCoord, vec4(finalColor, 1.0f));
    return;
}