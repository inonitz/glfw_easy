#version 460 core
layout(local_size_x =   5, local_size_y =   5, local_size_z =   5) in;
layout(rgba32f, binding = 1) writeonly restrict uniform image2D imageOut;

layout(location = 1) uniform float u_dt;
layout(location = 2) uniform float u_rand;
layout(location = 3) uniform int u_samplesPpx;
layout(location = 4) uniform int u_recurseDepth;


struct Ray
{
    vec3 origin;
    vec3 dir;
};
struct Sphere
{ 
    vec4 pos_radius;
};
struct Material 
{
    vec4 data; 
};
struct CameraTransform
{
    vec3  position;
    vec2  viewport;
    float focal_length; /* Distance from camera origin to camera Screen */
    uint  reserved;
};


layout(std430, binding=1) readonly buffer SceneData
{
    CameraTransform sceneCameraTransform;
    uint            sceneObjMaxLength;
    uint            sceneObjCurrLength;
    uint            reserved[2];
    Sphere          sceneObject[];
};


layout(std430, binding=2) readonly buffer SceneMaterialBuffer
{
    Material materials[];
};


layout(std430, binding=3) readonly buffer SceneObjectToMaterialBuffer
{
    // /*
    //     format:
    //     u8  materialType;
    //     u8  reserved;
    //     u16 indexInMaterialSSBO; (materials[])
    // */
    uint objectToMaterial[];
};




vec3 rayAt(in Ray ray, in float t) { return ray.origin + ray.dir * t; }
Ray  cameraGetRay(CameraTransform cam, vec3 rayOrigin, vec2 uv) /* Camera pointing towards -Z axis */
{
    vec3 rayDir;
    rayDir = cam.position - vec3( (vec2(0.5f) - uv) * cam.viewport, cam.focal_length);
    return Ray(rayOrigin, rayDir);
}





/* Using trascendenal constants for fun & profit */
const float c_infinity = 1. / 0.;
const float c_pi         = 3.14159265358979323846264338327950288;
const float c_sqrt2      = 1.41421356237309504880;
const float c_sqrt3      = 1.73205080756887729352;
const float c_phi        = 1.61803398874989484820;
const float c_ramanujan  = 262537412640768743.999999999999250073; /* e^( pi * sqrt(163) )*/
const float c_atan2      = 0.955316618124509278163;
const float c_chaitin    = 0.0078749969978123844;                 /* avg prob that a rand program will halt */
const float c_feigenbaum = 2.50290787509589282228;

float degrees_to_radians(float degrees) { return degrees * c_pi / 180.0f; }




uint pcg_hash(in uint x)
{
    x = x * 747796405u + 2891336453u;
    uint word = ((x >> ((x >> 28u) + 4u)) ^ x) * 277803737u;
    return (word >> 22u) ^ word;
}


float random( vec2 p )
{
    const vec2 r = vec2(23.1406926327792690, 2.6651441426902251);
    return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  
}


float uintToNormFloat(uint m) { 
    return uintBitsToFloat((m & 0x007FFFFFu) | 0x3F800000u ) - 1.0f; 
}


float random_norm(vec2 p) {
    return uintToNormFloat(floatBitsToUint(random(p)));
}


vec3 simpleRandUnitSphere(in vec2 texelCoord, uint sampleNum)
{
    vec3 r3 = vec3(
        random(  vec2(u_rand, random(texelCoord)       )),
        random(  vec2(u_rand, random(vec2(sampleNum))  )), 
        0
    );
    r3.z = random(r3.xy);
    return normalize(r3);
}


vec3 reflectRay(in vec3 ray_dir, in vec3 normal)
{
    return ray_dir - 2 * dot(ray_dir, normal) * normal;
}


vec3 refractRay(in vec3 ray, in vec3 normal, in float lambda)
{
	// /* lambda = eta / eta_prime */
	vec3 r_p, r_l;
	r_p = lambda * (ray - dot(ray, normal) * normal);
	r_l = sqrt( 1.0f - normal * dot(r_p, r_p) );
	return r_p - r_l;
}

float reflectance(in float cos_angle, in float refraction_idx)
{
    float r = (1 - refraction_idx) / (1 + refraction_idx);
    r *= r;
    return r + (1.0f - r) * pow( (1.0f - cos_angle), 5 ); 
}


bvec3 near_zero(in vec3 vec)
{
    return lessThan(abs(vec), vec3(1e-8));
}




struct SphereRayIntersectionResult
{
    float t;
    vec3  normal;
    uint  objectIndex;
};


void intersection(
    in  Ray    R, 
    in  Sphere S, 
    in  vec2   t_bounds, 
    out SphereRayIntersectionResult result
) {
    float a, b, ac, discrim;
    vec3 tmp;
    vec2 coef;


    tmp = R.origin - S.pos_radius.xyz;
    b = -1.0f * dot(R.dir, tmp); /* calculate -b */
    a = dot(R.dir, R.dir);
    ac = dot(tmp, tmp) - S.pos_radius.w * S.pos_radius.w;

    b  *= (1.0f / a);
    ac *= (1.0f / a);
    discrim = b * b - ac;

    result.t = float(discrim < 0.0f) * c_infinity;
    if(isinf(result.t))
        return;


    coef = vec2(
        b + sqrt(discrim),
        b - sqrt(discrim)
    );
    coef = mix(vec2(c_infinity), coef, 
        bvec2(
            t_bounds.x < coef.x && coef.x < t_bounds.y,
            t_bounds.x < coef.y && coef.y < t_bounds.y
        )
    );
    result.t = min(coef.x, coef.y);
    if(isinf(result.t))
        return;


    result.normal  = rayAt(R, result.t) - S.pos_radius.xyz;
    result.normal *= (1.0f / S.pos_radius.w);
    result.normal *= mix(-1.0f, 1.0f, dot(R.dir, result.normal) < 0.0f); /* set proper direction if vector is outwards/inwards */
    // result.normal *= float(!isinf(result.t));
    return;
}


void worldRayIntersection(
    in  Ray ray, 
    out SphereRayIntersectionResult result
) {    
    SphereRayIntersectionResult curr_result, min_result;
    vec2 t_limits = vec2(0.001f, c_infinity);


    min_result.t      = c_infinity;
    min_result.normal = vec3(0.0f);
    min_result.objectIndex = 0;
    for(int i = 0; i < sceneObjCurrLength; ++i)
    {
        intersection(ray, sceneObject[i], t_limits, curr_result);
        // if(isinf(curr_result.t)) 
        //     continue; /* considering we don't have hundreds of sceneObject, this should be fine without the conditional */

        
        if(curr_result.t < t_limits.y) {
            t_limits.y = curr_result.t;
            min_result = curr_result;
            min_result.objectIndex = i; /* objectIndex isn't relevant to the intersection function */
        }
    }
    result = min_result;
}


vec3 defaultRayColor(in Ray ray)
{
    vec3 unit = normalize(ray.dir);
    float t = 0.5f * (unit.y + 1.0f);
    
    return mix(
        vec3(1.0f, 1.0f, 1.0f),
        vec3(0.5f, 0.7f, 1.0f),
        t
    );
}




vec3 CalculatePixelColorDiffuse(in vec2 texelCoord)
{
    SphereRayIntersectionResult possibleHit;
    Ray  cameraRayAtUV;
    vec3 returnedColor;
    uint mulHalf = 0;
    int  i       = 0;
    bool cont    = true;


    /* Diffuse (Lambertian-Hemispherical) scattering */
    cameraRayAtUV = cameraGetRay(sceneCameraTransform, sceneCameraTransform.position, texelCoord);
    for(; i < u_recurseDepth && cont; ++i)
    {
        worldRayIntersection(cameraRayAtUV, possibleHit);
        cont = !isinf(possibleHit.t);
        if(cont) {
            ++mulHalf;
            cameraRayAtUV.origin = rayAt(cameraRayAtUV, possibleHit.t);
            cameraRayAtUV.dir = simpleRandUnitSphere(texelCoord, i);
            cameraRayAtUV.dir *= mix(-1.0f, 1.0f, dot(cameraRayAtUV.dir, possibleHit.normal) > 0);
        }
    }
    returnedColor = mix(
        defaultRayColor(cameraRayAtUV),
        vec3(0.0f),
        bvec3(i == u_recurseDepth)
    );
    return pow(0.5f, mulHalf) * returnedColor;
}


vec3 CalculatePixelColorLambertian(in vec2 texelCoord)
{
    SphereRayIntersectionResult possibleHit;
    Ray  cameraRayAtUV;
    vec4 materialData;
    uint obj_to_mat = 0;

    vec3 finalColor = vec3(1.0f);
    vec3 attenuatedColor;
    vec3 scatterDir;
    vec3 reflectDir;
    vec3 refractDir;

    vec3 OpDir;
    vec3 unitRay;
    vec3 randRay;
    float refract_ratio = 0.0f, cost, sint;
    int  i       = 0;
    bool cont    = true;


    cameraRayAtUV = cameraGetRay(sceneCameraTransform, sceneCameraTransform.position, texelCoord);
    for(; i < u_recurseDepth && cont; ++i)
    {
        worldRayIntersection(cameraRayAtUV, possibleHit);
        cont = !isinf(possibleHit.t);
        if(cont) {
            obj_to_mat = objectToMaterial[possibleHit.objectIndex];
            materialData = materials[  obj_to_mat >> 16 ].data;
        
            unitRay = normalize(cameraRayAtUV.dir);
            randRay = simpleRandUnitSphere(texelCoord, i);
            
            cameraRayAtUV.origin = rayAt(cameraRayAtUV, possibleHit.t);
            switch(obj_to_mat & 0xFF) {
                case 0:
                    OpDir = possibleHit.normal + randRay;
                    if(all(near_zero(OpDir)))
                        OpDir = possibleHit.normal;
                    
                    cameraRayAtUV.dir = OpDir;
                    attenuatedColor = materialData.xyz;
                    finalColor *= attenuatedColor;
                    break;
                case 1: /* if w == 0.0f then the metal is reflective as usual, otherwise it is fuzzy */
                    OpDir = reflectRay(unitRay, possibleHit.normal);
                    cameraRayAtUV.dir = OpDir + mix(randRay, vec3(0.0f), bvec3(materialData.w == +0.0f));
                    attenuatedColor = materialData.xyz;
		            
                    cont = dot(OpDir, possibleHit.normal) > 0.0f; /* stop the loop if scatter wasn't valid */
		            finalColor *= mix(vec3(0.0f), attenuatedColor, bvec3(cont)); 
                    break; 
                case 3:
                    cost = dot(unitRay, possibleHit.normal);
                    sint = sqrt( 1.0f - cost * cost );
                    refract_ratio = mix(
                        materialData.w, 
                        1.0f/materialData.w, 
                        cost > 0.0f /* front_face */
                    );
                    
                    // bool shouldReflect = (refract_ratio * sint > 1.0f) || reflectance(cost, refract_ratio) > randRay.y;
                    if(  (refract_ratio * sint > 1.0f) || reflectance(cost, refract_ratio) > randRay.y  ) {
                        cameraRayAtUV.dir = reflectRay(unitRay, possibleHit.normal);
                    } else {
                        cameraRayAtUV.dir = refractRay(unitRay, possibleHit.normal, refract_ratio);
                    }
                    // cameraRayAtUV.dir = mix(
                    //     refractRay(unitRay, possibleHit.normal, refract_ratio),
                    //     reflectRay(unitRay, possibleHit.normal),
                    //     bvec3(shouldReflect) /* if refraction not possible */
                    // );
                    break;
                default:
                break;
            }
        }
    }
    finalColor = mix(finalColor, vec3(0.0f), bvec3(i == u_recurseDepth));
    return mix(
        defaultRayColor(cameraRayAtUV),
        finalColor,
        bvec3(i == u_recurseDepth)
    );
}


vec3 CalculatePixelColorLambertianOnly(in vec2 texelCoord)
{
    SphereRayIntersectionResult possibleHit;
    Ray  cameraRayAtUV;
    vec4 materialData;
    vec3 finalColor = vec3(1.0f);
    vec3 attenuatedColor;
    vec3 scatterDir;
    int  i       = 0;
    bool cont    = true;


    cameraRayAtUV = cameraGetRay(sceneCameraTransform, sceneCameraTransform.position, texelCoord);
    for(; i < u_recurseDepth && cont; ++i)
    {
        worldRayIntersection(cameraRayAtUV, possibleHit);
        cont = !isinf(possibleHit.t);
        if(cont) {
            materialData = materials[  objectToMaterial[possibleHit.objectIndex] >> 16 ].data;
            scatterDir = possibleHit.normal + simpleRandUnitSphere(texelCoord, i);
            // if(all(near_zero(scatterDir))) scatterDir = possibleHit.normal;


            cameraRayAtUV.origin = rayAt(cameraRayAtUV, possibleHit.t);
            cameraRayAtUV.dir    = scatterDir;
            attenuatedColor = materialData.xyz;
            finalColor *= attenuatedColor;
        }
    }
    if(i == u_recurseDepth) {
        return vec3(0.0f);
    }
    return finalColor * defaultRayColor(cameraRayAtUV);
}



vec3 CalculatePixelColor(in vec2 texelCoord) 
{
    SphereRayIntersectionResult possibleHit;
    vec3 outColor = vec3(0.0f);
    Ray  cameraRayAtUV;
    vec2 currTexel;
    const float pixel_samples_inv = 1.0f / float(u_samplesPpx);


    for(uint sampleIdx = 0; sampleIdx < u_samplesPpx; ++sampleIdx) {
        currTexel = texelCoord + simpleRandUnitSphere(texelCoord, sampleIdx).xz * pixel_samples_inv * pixel_samples_inv;
        outColor += CalculatePixelColorLambertianOnly(currTexel);
    }

    outColor *= pixel_samples_inv; /* Get Average over All Samples */
    return outColor;
}


void main()
{
    /* intermediates for calculations */
    vec3 finalColor = vec3(0.0f);

    /* Image Output Coordinates (pixel uv coord) */
    ivec2 texelCoord  = ivec2(gl_GlobalInvocationID.xy);
    vec2  texelCoordf = vec2(texelCoord) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy); 


    finalColor = pow( /* gamma correction */
        CalculatePixelColor(texelCoordf),
        vec3(0.45454545453f)
    );
    imageStore(imageOut, texelCoord, vec4(finalColor, 1.0f));
    return;
}
